"""
문제

반올림을 이상하게 하는 프로그램이 있습니다. 이 프로그램은 아래와 같은 방식으로 반올림을 진행합니다.

1. 가장 마지막 자리수에 대해서, 5 이상이면 해당 자리에서 올림한다.
2. 가장 마지막 자리수를 제거한다.
3. 1~2의 과정을 여러 번 반복한다.
예를 들어서, 4.6445 -> 4.645 -> 4.65 -> 4.7 처럼 반올림을 할 수 있습니다. (각주: 0.68995 -> 0.6900 -> 0.690 -> 0.69 -> 0.7이 됩니다.)

소수 k가 주어지면, 위와 같은 반올림 방법으로 k가 나오는 소수점 m자리 수의 개수를 구하세요.

입력

첫 번째 줄에 양의 정 m이 주어집니다. (1 ≤ m ≤ 1000)

두 번째 줄에 소수 k가 주어집니다. (0 < k ≤ 1000) 이때 k는 소수점 m자리 이하 소수임이 보장됩니다.

출력

프로그램의 반올림 결과가 k가 될 수 있는 소수점 m자리 수의 개수를 출력합니다.

가장 중요한 아이디어:

그냥 손으로 하나하나 세 봤다 ㅋㅋ
예외인 1.0 이 입력됐을 때, m=1일때는 0.5~0.9 5개이고, m=2 일떄부터는 다른 경우와 똑같다.
m과 소숫점 아래 수의 개수의 차이가 0일 때는 1, 1일떈 10, 2일땐 100, 3일땐 1000.. 등 규칙을 갖는데,
1.0일때만 1-100, 2-1000 으로 10배 차이가 난다. 1.0이 되려면 0.445 도 반올림 가능하기 때문에
아무튼 손으로 써보고, 예외 판단만 잘 하면 쉽게 로직을 짤 수 있는 문제였다.

"""
m= int(input())
k=input().split('.')
r=list(k[1])
if k[0]=='1' and k[1]=='0':
    if m==1:
        ans=5
    else:
        ans=10**m
else:
    ans=10**(m-len(r))
print(ans)

